<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta name="theme-color" content="#000000" />


    <!-- Babylon.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
    <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
    <script src="https://preview.babylonjs.com/ammo.js"></script>
    <script src="https://preview.babylonjs.com/cannon.js"></script>
    <script src="https://preview.babylonjs.com/Oimo.js"></script>
    <script src="https://preview.babylonjs.com/earcut.min.js"></script>
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

    <script src="https://unpkg.com/codeflask/build/codeflask.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/seedrandom@3.0.5/seedrandom.min.js"></script>
    <script src="https://unpkg.com/ipfs-http-client/dist/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>


    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        /* Snapshot registry styling */
        #snapshotList {
            background: rgba(30, 30, 30, 0.8);
            border-radius: 4px;
        }

        .snapshot-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            border-bottom: 1px solid #333;
            margin-bottom: 4px;
        }

        .snapshot-name {
            font-weight: bold;
            color: #adf;
        }

        .snapshot-date {
            font-size: 0.8em;
            color: #999;
            margin: 0 10px;
        }

        /* #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
    }
 */
        .header {
            padding: 20px;
            height: 140px;
            text-align: center;
            background: #1abc9c;
            color: white;
            font-size: 30px;
        }


        #inputs {
            width: 400px;
            height: 800px;
            border-radius: 3px;
            top: 0%;
            position: fixed;
            box-shadow: 0 2px 2px 0 rgba(#000, .14), 0 1px 5px 0 rgba(#000, .12), 0 3px 1px -2px rgba(#000, .2);
        }

        #controlpanel {
            position: absolute;
            left: 233px;
            top: 428px;
            width: 229px;
            height: 113px;
            color: white;
            font: 0.6rem Inconsolata, monospace;
            background-color: black;

        }

        #buttons {
            position: absolute;
            left: 233px;
            top: 548px;
            width: 229px;
            height: 30px;

        }


        #codeArea {
            width: 400px;
            height: 800px;
            border-radius: 3px;
            top: 0%;
            position: fixed;
            box-shadow: 0 2px 2px 0 rgba(#000, .14), 0 1px 5px 0 rgba(#000, .12), 0 3px 1px -2px rgba(#000, .2);
        }

        #codeArea2 {
            width: 500px;
            height: 1000px;
            border-radius: 3px;
            top: 0%;
            position: fixed;
            box-shadow: 0 2px 2px 0 rgba(#000, .14), 0 1px 5px 0 rgba(#000, .12), 0 3px 1px -2px rgba(#000, .2);
            right: 0%;
        }

        .profile {
            right: 30px;
            position: fixed;

        }

        .leftbottom {
            left: 5px;
            bottom: 5px;
            width: 444px;
            position: fixed;

        }

        .rightbottom {
            right: 0;
            bottom: 0;
            position: fixed;

        }

        .codeflask {
            width: 400px height: 83% border-radius: 3px
        }

        &::before,
        .codeflask__lines background: #FFF .codeflask__textarea
    </style>
</head>

<title>MetaLambda</title>
</head>

<body>

    <!-- IPFS Snapshot Panel -->
    <div id="snapPanelMinimized" style="position:fixed;right:8px;top:8px;background:#fff;padding:8px;border:1px solid #999;font-size:12px;z-index:9999;display:none;cursor:pointer;" onclick="toggleSnapPanel()">
        <strong>IPFS Snapshot Panel ►</strong>
    </div>
    
    <div id="snapPanel" style="position:fixed;right:8px;top:8px;background:#fff;padding:8px;border:1px solid #999;font-size:12px;z-index:9999">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
            <strong>IPFS Snapshot Panel</strong>
            <span style="cursor:pointer;font-weight:bold;" onclick="toggleSnapPanel()">▼</span>
        </div>
        
        Seed <input id="seed" size="18" />
        <button onclick="applySeed()">Apply</button>
        <button onclick="connectWallet()">Wallet Seed</button><br>
        <input id="snapshotName" placeholder="Snapshot Name" size="20" style="margin-right: 5px;">
        <button onclick="snapshotState()">Snapshot → IPFS</button><br>
        CID <input id="cid" size="48"><br>
        <button onclick="loadSnapshot()">Load CID</button>

        <h3 style="cursor: pointer; user-select: none;" onclick="toggleSnapshotRegistry()">
            <span id="registryToggle">▼</span> Snapshot Registry (Collection of All Snapshots)
        </h3>
        <div style="margin-bottom: 5px; font-size: 11px; color: #666;">
            The registry is a collection of all your saved snapshots. Each time you save a new snapshot, it's added to this registry.
        </div>
        <div style="margin-bottom: 5px;">
            <input id="registryCidInput" placeholder="Registry CID" size="30" style="font-size: 10px;">
            <button onclick="loadRegistryFromCid()" style="font-size: 10px;">Load Registry</button>
            <button onclick="showRegistryContents()" style="font-size: 10px;">Show Contents</button>
        </div>
        <div id="registryStatus" style="font-size: 10px; color: #666; margin-bottom: 5px;"></div>
        <div id="snapshotList"
            style="max-height: 200px; overflow-y: auto; margin-top: 10px; border: 1px solid #444; padding: 5px;">
            <!-- Snapshots will be listed here -->
        </div>

        <button onclick="showBlockNumber()">Block #</button> Age: <span id="ageDisplay">–</span>
        <hr style="margin:4px 0">
        Duel Seeds A <input id="seedA" size="8"> B <input id="seedB" size="8"><br>
        Steps <input id="duelSteps" size="5" value="1000"><br>
        <button onclick="publishDuel()">Duel → IPFS</button><br>
        Manifest CID <input id="manifestCid" size="46"><br>
        <button onclick="verifyDuel()">Verify CID</button><br>
        Index CID <input id="indexCid" size="46"><br>
        <button onclick="refreshDuelList()">Refresh List</button><br>
        <select id="duelList" size="4" style="width:98%" onchange="manifestCid.value=this.value"></select>
    </div>

    <div id="inputs">

        <h2>Game of MetaLife 0.44</h2>

        Address:<BR />
        <input id="address" type="text" size="45" onChange="reInitialize()"></input><BR />
        <input id="address2" type="text" size="45" onChange="reInitialize()"></input><BR />

        <table style="font-size:60%">
            <tr>
                <th>Name</th>
                <th>xFreq</th>
                <th>yFreq</th>
                <th>zFreq</th>
                <th>color</th>
                <th>split</th>
                <th>mutate</th>
            </tr>
            <tr>
                <td>Lifeform 1</td>
                <td><input id="xFreq" type="text" value="10" size="3"></input>
                </td>
                <td> <input id="yFreq" type="text" value="10" size="3"></input>
                </td>
                <td><input id="zFreq" type="text" value="10" size="3"></input>
                </td>
                <td> <input id="color" type="text" value="10" size="5" data-jscolor="" onchange="updateCAColor()">
                    </input>
                    </input>
                </td>
                <td> <input id="splitFreq" type="text" value="10" size="4"></input>
                    </input>
                </td>
                <td> <input id="mutation" type="text" value="10" size="4"></input><BR />
                    </input>
                </td>

            </tr>
            <tr>
                <td>Lifeform 2</td>
                <td><input id="xFreq2" type="text" value="10" size="3"></input>
                </td>
                <td> <input id="yFreq2" type="text" value="10" size="3"></input>
                </td>
                <td><input id="zFreq2" type="text" value="10" size="3"></input>
                </td>
                <td> <input id="color2" type="text" value="10" size="5" data-jscolor=""
                        onchange="updateCAColor()"></input>
                    </input>
                </td>
                <td> <input id="splitFreq2" type="text" value="10" size="4"></input>
                    </input>
                </td>
                <td> <input id="mutation2" type="text" value="10" size="4"></input><BR />
                    </input>
                </td>

            </tr>
        </table>

        <div style="width:200px;padding-top:10px;padding-left:10px">

            <!--This is an interactive 3d MetaLife simulator. Use "w" "a" "s" "d" and the mouse cursor to navigate.<BR/>-->
            The first three parameters determine the frequency of movement in the x,y,z coordinate space. The last two
            determine the frequency that it reproduces and the strength of mutation each time it splits.<BR />
            All of the code in the right panel can be changed for more specialised effects.

            <BR /><BR /><img src="./img/nav.png" width="180px" />
        </div>

    </div>
    <!--<div id="codeArea" class="codeflask">
  if(ca.xFreq > 100)
       current_x += 1;

  if(ca.yFreq > 100)
       current_y += 1;

  if(ca.zFreq > 100)
       current_z += 1;

  if(numberofComputationalStepsCompleted % ca.splitFreq == 0)
    {
      var splitCA = mutate(ca);
    }

 </div>-->
    <div class="leftbottom">
        Joel Dietz <a href="https://connection.mit.edu/joel-dietz" target="_blank">MIT</a> | <a
            href="http://www.fractastical.replit.app" target="_blank">ART</a> | <a href="https://youtu.be/HhNnnKV-h_Q"
            target="_blank">Ted Talk</a> |
        <a href="https://joel-dietz.gitbook.io/metalife/" target="_blank">Gitbook</a><BR />

        <!-- <label for="mode">Lambda:</label>

 <select name="mode" id="mode" onchange="initiateZuseMode()">
   <option value="ca">P</option>
   <option value="metaverseb">Fib Spiral</option>
 </select> 

        <!--<input id="test" type="button" value="run 1000 steps" onclick="runMetaStep(1000);"></input>-->
    </div>
    <div id="codeArea2" class="codeflask">
        if (ca.xFreq > 100) {
        if ((numberofComputationalStepsCompleted % 100) < (ca.xFreq % 100)) current_x +=1; } else if (ca.xFreq <=100) if
            ((numberofComputationalStepsCompleted % 100) < (ca.xFreq)) current_x -=1; if (ca.yFreq> 100) {
            if ((numberofComputationalStepsCompleted % 100) < (ca.yFreq % 100)) current_y +=1; } else if (ca.yFreq
                <=100) if ((numberofComputationalStepsCompleted % 100) < (ca.yFreq)) current_y -=1; if (ca.zFreq> 100) {
                if ((numberofComputationalStepsCompleted % 100) < (ca.zFreq % 100)) current_z +=1; } else if (ca.zFreq
                    <=100) if ((numberofComputationalStepsCompleted % 100) < (ca.zFreq)) current_z -=1; if
                    (numberofComputationalStepsCompleted !=0 && numberofComputationalStepsCompleted % ca.splitFreq==0) {
                    if (allActiveCAs.length < 12) { var splitCA=mutate(ca, ca.mutation); allActiveCAs.push(splitCA); } }
                    </div>
                    <!--  <div class="rightbottom">
  <input id="xFreq2" type="text" value="10" size="5"></input>
  <input id="yFreq2" type="text" value="10" size="5"></input>
  <input id="zFreq2" type="text" value="10" size="5"></input>
  <input id="color2" type="text" value="10" size="5"></input>
  <input id="splitFreq2" type="text" value="10" size="5"></input>
  <input id="mutation2" type="text" value="10" size="5"></input>
 </div>-->

                    <div class="profile">


                    </div>


                    <div style="position: relative;">
                        <!--<<canvas id="layer1" width="300px" height="300px"
       style="position: absolute; left: 0; top: 0; z-index: 0;"></canvas>
      canvas id="layer2" width="140" height="140"
       style="position: absolute; left: 233px; top: 198px; z-index: 1;"></canvas>-->
                        <canvas id="layer2" width="229" height="229"
                            style="position: absolute; left: 233px; top: 198px; z-index: 1;"></canvas>

                        <canvas id="layer3" width="60" height="60"
                            style="position: absolute; left: 433px; top: 198px;"></canvas>

                    </div>
                    <div id="controlpanel">
                        <div id="stats" style="padding:5px">
                            >>&nbsp;
                        </div>
                    </div>
                    <div id="buttons"> 
                        <input type="button" onclick="startSimulation(100)" value="Go 100 steps" />
                        <input type="button" onclick="startSimulation(1000)" value="Go 1000 steps" />
                        <!--<input type="button" onclick="combineMesh()" value="Combine Mesh" />-->
                        <input type="button" onclick="metaLifeExport()" value="Export" />
                        <a href="" id="lambdadownload" download="mlambda.txt">Download Code</a>
                        <!--<input type="button" onclick="reset()" value="Restart" />-->
                        <!-- <input type="button" onclick="loadFibLambda()" value="Fib Spiral" --> -->

                    </div>
                    <!-- <script src="./index.js"></script> -->
                    <script src="./jscolor.js"></script>
                    <script src="./metalambda.js"></script>

                    <script>
                        // Global registry of all snapshots
                        let snapshotRegistry = {
                            registryCID: null,  // CID of the registry itself
                            snapshots: [],      // Array of snapshot metadata
                            lastUpdate: 0       // Timestamp of last update
                        };
                        
                        // Default registry CID - this is your master registry that contains all snapshots
                        // Update this value with your latest registry CID when you have a good collection of snapshots
                        const DEFAULT_REGISTRY_CID = 'QmaYN8fBuCzgBhuWHKi2wWa6ajFgWyPXpWiDaUcns5B24y';

                        // Save the registry to IPFS
                        async function saveSnapshotRegistry() {
                            if (!ipfs) { log('IPFS not ready for registry save'); return; }

                            try {
                                // Update timestamp
                                snapshotRegistry.lastUpdate = Date.now();

                                // Save to IPFS
                                const { cid } = await ipfs.add(JSON.stringify(snapshotRegistry));
                                const cidStr = cid.toString();

                                // Update registry with its own CID
                                snapshotRegistry.registryCID = cidStr;

                                // Store in localStorage for persistence
                                localStorage.setItem('metaLifeRegistryCID', cidStr);
                                
                                // Update the registry status display
                                updateRegistryStatus();

                                log(`Registry updated: now contains ${snapshotRegistry.snapshots.length} snapshots total`);  
                                log(`Registry CID (save this to reload later): ${cidStr}`);
                                return cidStr;
                            } catch (err) {
                                console.error('[MetaLife] Registry save failed:', err);
                                return null;
                            }
                        }
                        
                        // Update the registry status display
                        function updateRegistryStatus() {
                            const statusEl = document.getElementById('registryStatus');
                            if (!statusEl) return;
                            
                            const cid = snapshotRegistry.registryCID || localStorage.getItem('metaLifeRegistryCID');
                            if (cid) {
                                statusEl.innerHTML = `Current Registry: <span style="font-family:monospace;">${cid}</span> <button onclick="copyRegistryCID()" style="font-size:9px;padding:0 3px;">Copy</button>`;
                                
                                // Also update the input field for convenience
                                const cidInput = document.getElementById('registryCidInput');
                                if (cidInput) cidInput.value = cid;
                            } else {
                                statusEl.innerHTML = 'No registry loaded';
                            }
                        }
                        
                        // Copy registry CID to clipboard
                        function copyRegistryCID() {
                            const cid = snapshotRegistry.registryCID || localStorage.getItem('metaLifeRegistryCID');
                            if (cid) {
                                navigator.clipboard.writeText(cid).then(() => {
                                    log('Registry CID copied to clipboard');
                                });
                            }
                        }

                        // Update the UI with the snapshot list
                        function updateSnapshotListUI() {
                            const snapshotList = document.getElementById('snapshotList');
                            if (!snapshotList) {
                                console.error('Snapshot list element not found');
                                return;
                            }

                            // Clear existing list
                            snapshotList.innerHTML = '';
                            
                            // Check if we have snapshots
                            if (!snapshotRegistry || !snapshotRegistry.snapshots || !snapshotRegistry.snapshots.length) {
                                snapshotList.innerHTML = '<div style="padding:5px;color:#666;">No snapshots found</div>';
                                return;
                            }
                            
                            log(`Updating UI with ${snapshotRegistry.snapshots.length} snapshots`);
                            
                            // Add each snapshot to the list
                            snapshotRegistry.snapshots.forEach((snapshot, index) => {
                                if (!snapshot || !snapshot.cid) return; // Skip invalid entries
                                
                                const item = document.createElement('div');
                                item.style.margin = '5px 0';
                                item.style.padding = '5px';
                                item.style.borderBottom = '1px solid #ddd';
                                item.style.display = 'flex';
                                item.style.justifyContent = 'space-between';
                                item.style.alignItems = 'center';
                                
                                const date = snapshot.timestamp ? new Date(snapshot.timestamp).toLocaleString() : 'Unknown date';
                                
                                item.innerHTML = `
                                    <div>
                                        <div style="font-weight:bold;">${snapshot.name || `Snapshot ${index + 1}`}</div>
                                        <div style="font-size:10px;color:#666;">${date}</div>
                                        <div style="font-size:10px;color:#999;">${snapshot.cid.substring(0, 16)}...</div>
                                    </div>
                                    <button onclick="loadSnapshotById('${snapshot.cid}')" style="padding:3px 8px;cursor:pointer;">Load</button>
                                `;
                                snapshotList.appendChild(item);
                            });
                        }

                        // Load a snapshot by its ID from the registry
                        async function loadSnapshotById(cid) {
                            document.getElementById('cid').value = cid;
                            await loadSnapshot();
                        }

                        // Load the registry from IPFS
                        async function loadSnapshotRegistry() {
                            if (!window.ipfs) { 
                                log('IPFS not ready for registry load, will retry'); 
                                setTimeout(() => loadSnapshotRegistry(), 2000);
                                return; 
                            }
                            
                            // Store reference to IPFS client
                            ipfs = window.ipfs;
                            
                            // Debug all localStorage items
                            log('Checking localStorage for registry CID...');
                            for (let i = 0; i < localStorage.length; i++) {
                                const key = localStorage.key(i);
                                console.log(`localStorage[${key}] = ${localStorage.getItem(key)}`);
                            }

                            // Check if we have a registry CID in localStorage or use default
                            let registryCID = localStorage.getItem('metaLifeRegistryCID');
                            
                            // If no registry in localStorage, use the default
                            if (!registryCID && DEFAULT_REGISTRY_CID) {
                                registryCID = DEFAULT_REGISTRY_CID;
                                log('Using default registry CID: ' + registryCID);
                                localStorage.setItem('metaLifeRegistryCID', registryCID);
                            } else if (!registryCID) {
                                log('No registry found, creating new one');
                                return;
                            }
                            
                            log('Registry CID to load: ' + registryCID);
                            
                            // Update the registry status display
                            updateRegistryStatus();

                            try {
                                log('Loading snapshot registry from IPFS:', registryCID);
                                let dataStr = '';
                                for await (const chunk of ipfs.cat(registryCID)) {
                                    dataStr += new TextDecoder().decode(chunk);
                                }
                                
                                if (!dataStr) {
                                    log('Empty registry data received');
                                    return;
                                }

                                const registry = JSON.parse(dataStr);
                                if (!registry || !registry.snapshots || !Array.isArray(registry.snapshots)) {
                                    log('Invalid registry format');
                                    return;
                                }
                                
                                snapshotRegistry = registry;
                                snapshotRegistry.registryCID = registryCID;
                                log(`Registry loaded with ${registry.snapshots.length} snapshots`);

                                // Update the UI with snapshot list
                                updateSnapshotListUI();
                                
                                // Log the snapshots for debugging
                                console.log('Loaded snapshots:', snapshotRegistry.snapshots);
                            } catch (err) {
                                console.error('[MetaLife] Registry load failed:', err);
                                log('Failed to load registry, starting fresh');
                            }
                        }

                        // Initialize the app with registry loading
                        (function initializeApp() {
                            // Wait for IPFS to be ready
                            const checkIpfs = () => {
                                if (window.ipfs) {
                                    log('IPFS ready, loading snapshot registry...');
                                    loadSnapshotRegistry();
                                } else {
                                    setTimeout(checkIpfs, 1000); // Check again in 1 second
                                }
                            };

                            // Start checking for IPFS after page load
                            window.addEventListener('load', () => {
                                setTimeout(checkIpfs, 2000); // Give IPFS time to initialize
                            });
                        })();

                        // Helper function to log messages
                        function log(message, ...args) {
                            const stats = document.getElementById('stats');
                            if (stats) {
                                const timestamp = new Date().toLocaleTimeString();
                                stats.innerHTML += `<br/>${timestamp} ${message} ${args.join(' ')}`;
                                stats.scrollTop = stats.scrollHeight;
                            }
                            console.log('[MetaLife]', message, ...args);
                        }
                        
                        // Function to toggle the visibility of the snapshot registry
                        function toggleSnapshotRegistry() {
                            const snapshotList = document.getElementById('snapshotList');
                            const toggleIcon = document.getElementById('registryToggle');
                            
                            if (snapshotList.style.display === 'none') {
                                // Expand
                                snapshotList.style.display = 'block';
                                toggleIcon.innerHTML = '▼';
                            } else {
                                // Collapse
                                snapshotList.style.display = 'none';
                                toggleIcon.innerHTML = '►';
                            }
                        }
                        
                        // Function to manually load a registry from a CID
                        async function loadRegistryFromCid() {
                            const cidInput = document.getElementById('registryCidInput');
                            if (!cidInput || !cidInput.value) {
                                alert('Please enter a registry CID');
                                return;
                            }
                            
                            const cid = cidInput.value.trim();
                            log('Manually loading registry from CID: ' + cid);
                            
                            // Save to localStorage
                            localStorage.setItem('metaLifeRegistryCID', cid);
                            
                            // Load the registry
                            await loadSnapshotRegistry();
                        }
                        
                        // Function to display registry contents in console
                        function showRegistryContents() {
                            console.log('Current Registry Contents:', JSON.stringify(snapshotRegistry, null, 2));
                            log(`Registry has ${snapshotRegistry.snapshots?.length || 0} snapshots`);
                            
                            if (snapshotRegistry.snapshots && snapshotRegistry.snapshots.length > 0) {
                                snapshotRegistry.snapshots.forEach((snapshot, i) => {
                                    log(`Snapshot ${i+1}: ${snapshot.name || 'Unnamed'} - CID: ${snapshot.cid}`);
                                });
                            } else {
                                log('No snapshots in registry');
                            }
                            
                            // Force update the UI
                            updateSnapshotListUI();
                        }
                        
                        // Function to toggle the entire IPFS Snapshot Panel
                        function toggleSnapPanel() {
                            const panel = document.getElementById('snapPanel');
                            const minimized = document.getElementById('snapPanelMinimized');
                            
                            if (panel.style.display === 'none') {
                                // Expand
                                panel.style.display = 'block';
                                minimized.style.display = 'none';
                            } else {
                                // Collapse
                                panel.style.display = 'none';
                                minimized.style.display = 'block';
                            }
                        }

                        function startSimulation(steps = 1000) {
                            // Add the specified number of steps to the maximum
                            MAXSTEPS += steps;
                            numberofComputationalStepsCompleted++;
                            log(`Running ${steps} more steps...`);
                        }

                        function metaLifeExport() {
                            alert("Beginning export");

                            /* scene.boundingInfo().centerOn(new BABYLON.Vector3(startingSize/2, startingSize/2,startingSize/2)) */
                            engine.stopRenderLoop();



                            BABYLON.GLTF2Export.GLTFAsync(scene, "metalife").then((gltf) => {
                                gltf.downloadFiles();
                            });

                        }

                        var canvas = document.getElementById("layer2");
                        let frameCount = 0;
                        var startRenderLoop = function (engine, canvas) {
                            engine.runRenderLoop(function () {
                                if (sceneToRender && sceneToRender.activeCamera) {
                                    // evolve voxel automata every 3 frames
                                    if (frameCount++ % 3 === 0 && window.allActiveCAs) {
                                        for (const ca of window.allActiveCAs) {
                                            if (ca.liveVoxels) stepVoxels(ca);
                                        }
                                    }
                                    sceneToRender.render();
                                }
                            });
                        }

                        var engine = null;
                        var scene = null;
                        var playingField = null;
                        var skySphere = null;
                        var sceneToRender = null;

                        var raySeedStrength = 10;
                        var ship1xDir = .3;
                        var ship1yDir = 1;
                        var ship1zDir = .9;
                        var ray2SeedStrength = 10;
                        var ship2xDir = -1;
                        var ship2yDir = -.3;
                        var ship2zDir = -.8;

                        /* var cubePattern = BABYLON.Mesh.CreateBox("box", 1.0, scene); */


                        // var parse = require('codeflask');

                        // import CodeFlask from 'codeflask';

                        var createDefaultEngine = function () {
                            return new BABYLON.Engine(canvas, true, {
                                // preserveDrawingBuffer: true,
                                // stencil: true,
                                // disableWebGL2Support: false
                            });
                        };
                        var createScene = function () {


                            // var cubePattern = BABYLON.MeshBuilder.CreateBox("box", {
                            //     size: 1
                            // }, scene);
                            // var cubePattern = BABYLON.Mesh.CreateBox("box", 1.0, scene);

                            // This creates a basic Babylon Scene object (non-mesh)
                            var scene = new BABYLON.Scene(engine);
                            const startingSize = 120;
                            scene.clearColor = BABYLON.Color3.Black();

                            // No decorative spiral - removed

                            /* window.cubePattern = BABYLON.MeshBuilder.CreateBox("box", {
                                size: 1
                            }, scene);
                    
                            window.cubePattern.material = new BABYLON.StandardMaterial("matBallon", scene);
                            window.cubePattern.material.emissiveColor = new BABYLON.Color3.FromHexString("#ffffff"); */

                            // This creates and positions a free camera (non-mesh)
                            // var camera = new BABYLON.ArcRotateCamera("camera1",  Math.PI / 1, 6 * Math.PI / 12, 150, new BABYLON.Vector3(0, 1, 0), scene);
                            // var rot_state = {x:camera.alpha , y:camera.beta};
                            // // This targets the camera to scene origin
                            // camera.setTarget(BABYLON.Vector3.Zero());
                            var camera = new BABYLON.FlyCamera("FlyCamera", new BABYLON.Vector3(50, 50, -100), scene);

                            // camera.angularSensibilityX = 1;
                            // camera.angularSensibilityY = 1;

                            // This attaches the camera to the canvas
                            camera.attachControl(canvas, true);

                            // chose

                            function setupPlayingField() {

                                // var defaultGridMaterial = new BABYLON.GridMaterial("default", scene);
                                // defaultGridMaterial.majorUnitFrequency = 5;
                                // defaultGridMaterial.gridRatio = 0.5;
                                //
                                // var defaultGridMaterial2 = new BABYLON.GridMaterial("ca2", scene);
                                // defaultGridMaterial2.majorUnitFrequency = 4;
                                // defaultGridMaterial2.gridRatio = 0.4;
                                // defaultGridMaterial2.lineColor = BABYLON.Color3(0.72, 0, 0);


                                // playingField = BABYLON.MeshBuilder.CreateBox("box", {
                                //     size: startingSize
                                // }, scene);
                                // playingField.material = defaultGridMaterial;
                                // playingField.position.x = 50;
                                // playingField.position.y = 50;
                                // playingField.position.z = 50;

                                // defaultGridMaterial.alpha = 0.2;
                                // defaultGridMaterial.opacity = 0.6;

                                // var skyMaterial = new BABYLON.GridMaterial("skyMaterial", scene);
                                // skyMaterial.majorUnitFrequency = 6;
                                // skyMaterial.minorUnitVisibility = 0.43;
                                // skyMaterial.gridRatio = 0.5;
                                // skyMaterial.mainColor = new BABYLON.Color3(0, 0.05, 0.2);
                                // skyMaterial.lineColor = new BABYLON.Color3(0, 1.0, 1.0);
                                // skyMaterial.backFaceCulling = false;
                                //
                                // skySphere = BABYLON.Mesh.CreateSphere("skySphere", 300, 450, scene);
                                // skySphere.material = skyMaterial;


                            }


                            function createEnergy() {
                                var cube = BABYLON.MeshBuilder.CreateBox("box", {
                                    size: 1
                                }, scene);
                                cube.material = new BABYLON.StandardMaterial("matBallon", scene);
                                cube.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
                                cube.material.alpha = 0.33;

                                cube.position.y = Math.floor(Math.random() * startingSize) + 1;
                                cube.position.x = Math.floor(Math.random() * startingSize) + 1;
                                cube.position.z = Math.floor(Math.random() * startingSize) + 1;
                                cube.energy = 10;
                                var cubeIndex = cube.position.y + cube.position.x + cube.position.z;
                                cubeList.push(cube);
                                sortedCubeList[cubeIndex] = cube;

                            }

                            /* var ca1 = BABYLON.MeshBuilder.CreateBox("box", { size : 4}, scene);
                    
                            var ca1 = BABYLON.Mesh.CreateSphere("balloon1", 10, 4.0, scene);
                            ca1.material = new BABYLON.StandardMaterial("matBallon", scene);
                            ca1.material.ambientColor = new BABYLON.Color3.FromHexString("#" + colora + colorb + colorc);
                            ca1.material.diffusiveColor = new BABYLON.Color3.FromHexString("#" + colora + colorb + colorc);
                            ca1.material.emmissiveColor = new BABYLON.Color3.FromHexString("#" + colora + colorb + colorc);
                            ca1.position = new BABYLON.Vector3(positionX, positionY, positionZ);
                            ca1.energy = startingEnergyEnergy;
                            ca1.seed = (Math.random() * 100);
                            ca1.color = "#" + colora + colorb + colorc;
                            ca1.xFreq = xFreq;
                            ca1.yFreq = yFreq;
                            ca1.zFreq = zFreq;
                            ca1.splitFreq = splitFreq;
                            ca1.mutation = mutation;
                    
                            allActiveCAs.push(ca1);
                    
                    
                            var ca2 = BABYLON.MeshBuilder.CreateBox("box", { size : 4}, scene);
                            ca2.material = new BABYLON.StandardMaterial("matBallon", scene);
                            ca2.material.ambientColor = new BABYLON.Color3.FromHexString("#" + colora2 + colorb2 + colorc2);
                            ca2.material.diffusiveColor = new BABYLON.Color3.FromHexString("#" + colora2 + colorb2 + colorc2);
                            ca2.material.emissiveColor = new BABYLON.Color3.FromHexString("#" + colora2 + colorb2 + colorc2);
                            ca2.position = new BABYLON.Vector3(positionX2, positionY2, positionZ2);
                            ca2.energy = startingEnergyEnergy;
                            ca2.seed = (Math.random() * 100);
                            ca2.color = "#" + colora2 + colorb2 + colorc2;
                            ca2.xFreq = xFreq2;
                            ca2.yFreq = yFreq2;
                            ca2.zFreq = zFreq2;
                            ca2.splitFreq = splitFreq2;
                            ca2.mutation = mutation2;
                    
                    
                            allActiveCAs.push(ca2);  */


                            /* function initiateZuseMode() {
                    
                              LEAVETRAIL = false;
                    
                              BABYLON.SceneLoader.ImportMesh("", "/models/islands/", "basic_floating_island.glb", scene, function (newMeshes, particleSystems, skeletons) {
                              var island = newMeshes[0];
                    
                              island.rotation.y = Math.PI / 2;
                              island.position = new BABYLON.Vector3(50, 50, 50);
                    
                              // scene.beginAnimation(skeletons[0], 0, 100, true, 1.0);
                    
                              // scene.createDefaultCamera(1,1,1);
                    
                            });
                    
                    
                            } */
                            /*
                    
                                        for (let i=1;i < 3;i++)
                                        {
                                          var newCA = BABYLON.Mesh.CreateSphere("balloon1", 10, 2.0, scene);
                                          newCA.material = new BABYLON.StandardMaterial("matBallon", scene);
                                          newCA.material.emissiveColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
                                          newCA.position = new BABYLON.Vector3((Math.random()*startingSize), (Math.random()*startingSize), (Math.random()*startingSize));
                                          newCA.energy = startingEnergyEnergy;
                                          newCA.seed = (Math.random()*100);
                                          newCA.xFreq = (Math.random()*200);
                                          newCA.yFreq = (Math.random()*200);
                                          newCA.zFreq = (Math.random()*200);
                    
                                          allActiveCAs.push(newCA);
                                        }
                             */



                            function buyCA() {
                                var newCA = BABYLON.Mesh.CreateSphere("balloon1", 10, 2.0, scene);
                                newCA.material = new BABYLON.StandardMaterial("matBallon", scene);
                                newCA.material.emissiveColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
                                newCA.position = new BABYLON.Vector3((Math.random() * startingSize), (Math.random() * startingSize), (Math.random() * startingSize));
                                newCA.energy = startingEnergyEnergy;
                                newCA.seed = (Math.random() * startingSize);

                                allActiveCAs.push(newCA);
                            }

                            function combineMesh() {


                            }


                            setupPlayingField();
                            reInitialize();

                            // for (let i = 0; i < startingNumberOfCubes; i++)
                            //     createEnergy();
                            // createCAs();
                            // when button is pressed, run one computational step


                            // GUI
                            var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");


                            var compstepbutton = BABYLON.GUI.Button.CreateSimpleButton("csb1", numberOfComputationalStepsPerGame + " remaining");
                            compstepbutton.width = "150px"
                            compstepbutton.height = "40px";
                            compstepbutton.color = "black";
                            compstepbutton.top = -320;
                            compstepbutton.left = -170;
                            compstepbutton.cornerRadius = 20;
                            compstepbutton.background = "white";
                            compstepbutton.onPointerUpObservable.add(function () {

                                BABYLON.GLTF2Export.GLTFAsync(scene, "fileName").then((gltf) => {
                                    gltf.downloadFiles();
                                });


                            });
                            advancedTexture.addControl(compstepbutton);

                            var ship1;
                            var ship2;

                            var modei = 0;
                            var modes = ["Default Mode", "Combat Mode"]
                            var activeMode = "";
                            var modeswitchbutton = BABYLON.GUI.Button.CreateSimpleButton("msb1", "Default mode");
                            modeswitchbutton.width = "150px"
                            modeswitchbutton.height = "40px";
                            modeswitchbutton.color = "black";
                            modeswitchbutton.top = -320;
                            modeswitchbutton.left = 170;
                            modeswitchbutton.cornerRadius = 20;
                            modeswitchbutton.background = "white";
                            modeswitchbutton.onPointerUpObservable.add(function () {

                                modei++;
                                if (modei >= modes.length)
                                    modei = 0;
                                activeMode = modes[modei];
                                modeswitchbutton.textBlock.text = activeMode;
                                if (modei == 1) {
                                    BABYLON.SceneLoader.ImportMesh("", "/", "UFO.glb", scene, function (newMeshes, particleSystems, skeletons) {
                                        ship1 = newMeshes[0];

                                        ship1.rotation.y = Math.PI / 2;
                                        ship1.position = new BABYLON.Vector3(1, 1, 1);

                                        // scene.beginAnimation(skeletons[0], 0, 100, true, 1.0);

                                        // scene.createDefaultCamera(1,1,1);


                                    });

                                    BABYLON.SceneLoader.ImportMesh("", "/", "igspaceship2.glb", scene, function (newMeshes, particleSystems, skeletons) {
                                        ship2 = newMeshes[0];

                                        ship2.rotation.y = Math.PI / 2;
                                        ship2.position = new BABYLON.Vector3(startingSize, startingSize, startingSize);

                                        // scene.beginAnimation(skeletons[0], 0, 100, true, 1.0);

                                        // scene.createDefaultCamera(1,1,1);


                                    });

                                    //
                                    // BABYLON.SceneLoader.Append("", "Intergalactic_Spaceships_Version_2.glb", scene, function (scene) {
                                    //     // Create a default arc rotate camera and light.
                                    //     scene.createDefaultCameraOrLight(true, true, true);
                                    //
                                    //     // The default camera looks at the back of the asset.
                                    //     // Rotate the camera by 180 degrees to the front of the asset.
                                    //     scene.activeCamera.alpha += Math.PI;
                                    // });

                                }


                            });
                            advancedTexture.addControl(modeswitchbutton);


                            var buyCAButton = BABYLON.GUI.Button.CreateSimpleButton("but1", "Create MetaLife");
                            buyCAButton.width = "150px"
                            buyCAButton.height = "40px";
                            buyCAButton.color = "white";
                            buyCAButton.top = -200;
                            buyCAButton.left = 1;
                            buyCAButton.cornerRadius = 20;
                            buyCAButton.background = "green";
                            buyCAButton.onPointerUpObservable.add(function () {
                                if (team1points > 9) {

                                    buyCA();
                                    team1points -= 5;
                                    ca1lbutton.textBlock.text = team1points + " points";


                                }

                            });
                            advancedTexture.addControl(buyCAButton);


                            var team1points = 10;
                            var team2points = 0;

                            var ca1lbutton = BABYLON.GUI.Button.CreateSimpleButton("t1p", team1points + " energy");
                            ca1lbutton.width = "150px"
                            ca1lbutton.height = "40px";
                            ca1lbutton.color = "white";
                            ca1lbutton.top = -240;
                            ca1lbutton.left = -170;
                            ca1lbutton.cornerRadius = 20;
                            ca1lbutton.background = "blue";
                            ca1lbutton.onPointerUpObservable.add(function () {

                                buyCA();

                            });


                            advancedTexture.addControl(ca1lbutton);
                            var ca2lbutton = BABYLON.GUI.Button.CreateSimpleButton("t1p", team1points + " energy");


                            function vecToLocal(vector, mesh) {
                                var m = mesh.getWorldMatrix();
                                var v = BABYLON.Vector3.TransformCoordinates(vector, m);
                                return v;
                            }

                            var raySeedStrength = 10;
                            var ship1xDir = .3;
                            var ship1yDir = 1;
                            var ship1zDir = .9;

                            var ray2SeedStrength = 10;
                            var ship2xDir = -1;
                            var ship2yDir = -.3;
                            var ship2zDir = -.8;

                            function castRay() {

                                var origin = ship1.position;

                                var microseed = Math.random() * raySeedStrength;

                                var forward = new BABYLON.Vector3(-7 + microseed, 4 + microseed, 2 + microseed);
                                forward = vecToLocal(forward, ship1);

                                var direction = forward.subtract(origin);
                                direction = BABYLON.Vector3.Normalize(direction);

                                var length = 33;

                                var ray = new BABYLON.Ray(origin, direction, length);
                                var rayHelper = new BABYLON.RayHelper(ray);

                                var localMeshDirection = new BABYLON.Vector3(0, 0, 1);
                                var localMeshOrigin = new BABYLON.Vector3(0, 0, .4);
                                var length = 33;

                                // rayHelper.attachToMesh(ship1, origin, direction, length);
                                rayHelper.show(scene);

                                var hits = scene.multiPickWithRay(ray);

                                if (hits) {
                                    console.log("hits:" + hits.length);
                                    for (var i = 0; i < hits.length; i++) {
                                        if (hits[i] != playingField && hits[i] != skySphere); {
                                            hits[i].pickedMesh.dispose();

                                            /* hits[i].pickedMesh.scaling.y -= 0.1;
                                            hits[i].pickedMesh.alpha = .05; */
                                            team1points += 1;
                                            ca1lbutton.textBlock.text = team1points + " points";

                                        }
                                    }
                                }
                            }

                            function castRay2() {

                                var origin = ship2.position;

                                var microseed = Math.random() * ray2SeedStrength;

                                var forward = new BABYLON.Vector3(7 - microseed, -4 - microseed, -2 - microseed);

                                forward = vecToLocal(forward, ship2);

                                var direction = forward.subtract(origin);
                                direction = BABYLON.Vector3.Normalize(direction);

                                var length = 33;

                                var ray = new BABYLON.Ray(origin, direction, length);
                                var rayHelper = new BABYLON.RayHelper(ray);

                                var localMeshDirection = new BABYLON.Vector3(0, 0, 1);
                                var localMeshOrigin = new BABYLON.Vector3(0, 0, .4);
                                var length = 33;

                                // rayHelper.attachToMesh(ship2, origin, direction, length);
                                rayHelper.show(scene);

                                var hits = scene.multiPickWithRay(ray);

                                if (hits) {
                                    console.log("hits:" + hits.length);
                                    for (var i = 0; i < hits.length; i++) {
                                        if (hits[i] != playingField); {
                                            hits[i].pickedMesh.dispose();
                                            team2points += 1;
                                            ca2lbutton.textBlock.text = team2points + " points";

                                        }
                                    }
                                }
                            }

                            var metaEnergyCount = 0;
                            setTimeout(() => {
                                console.log("World!");
                            }, 50000);


                            const INTERACTION_DIST = 4; // units

                            scene.beforeRender = () => {

                                metaEnergyCount++;
                                if (numberofComputationalStepsCompleted > 0 && numberofComputationalStepsCompleted <= MAXSTEPS)
                                    runOneStep();

                                // --- Lifeform interactions ---
                                if (window.allActiveCAs && allActiveCAs.length > 1) {
                                    for (let i = 0; i < allActiveCAs.length; i++) {
                                        for (let j = i + 1; j < allActiveCAs.length; j++) {
                                            const a = allActiveCAs[i];
                                            const b = allActiveCAs[j];
                                            if (!a || !b) continue;
                                            const dist = BABYLON.Vector3.Distance(a.position, b.position);
                                            if (dist < INTERACTION_DIST) {
                                                // blend colors
                                                const colA = a.material.emissiveColor;
                                                const colB = b.material.emissiveColor;
                                                const blended = new BABYLON.Color3(
                                                    (colA.r + colB.r) / 2,
                                                    (colA.g + colB.g) / 2,
                                                    (colA.b + colB.b) / 2
                                                );
                                                a.material.emissiveColor = blended;
                                                b.material.emissiveColor = blended;

                                                // slight push apart to avoid overlap
                                                const dir = a.position.subtract(b.position).normalize().scale(0.1);
                                                a.position.addInPlace(dir);
                                                b.position.addInPlace(dir.scale(-1));
                                            }
                                        }
                                    }
                                }

                            };



                            // scene.registerBeforeRender(function () {
                            //     castRay();
                            // });



                            engine.runRenderLoop(function () {
                                camera.alpha += 0.003;
                            });

                            return scene;
                        };
                        window.initFunction = async function () {


                            var asyncEngineCreation = async function () {
                                try {
                                    return createDefaultEngine();
                                } catch (e) {
                                    console.log("the available createEngine function failed. Creating the default engine instead");
                                    return createDefaultEngine();
                                }
                            }

                            window.engine = await asyncEngineCreation();
                            if (!engine) throw 'engine should not be null.';
                            startRenderLoop(engine, canvas);
                            window.scene = createScene();
                        };
                        initFunction().then(() => {
                            sceneToRender = scene
                        });

                        // Resize
                        window.addEventListener("resize", function () {
                            engine.resize();
                        });

                        /* const code1 = new CodeFlask('#codeArea', {
                            language: 'js',
                            lineNumbers: true
                        }) */


                        function reset() {

                            createScene();
                            /* window.scene = createScene(); */

                        }




                    </script>
                    <script>
                        let ipfs;
                        const ethProvider = new ethers.providers.JsonRpcProvider('https://rpc.ankr.com/eth');
                        const PINATA_API_KEY = '93f5cca309fe273fcb8b';
                        const PINATA_SECRET = '2d5bc4f4437bdb6bad92f7d0e79e0512e15fcc09fd4e435979a33b85dc02c859';
                        const PINATA_JWT = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySW5mb3JtYXRpb24iOnsiaWQiOiI5ZGRlOWFlNS0wYjIxLTQ0MGUtYWMzZC05NDllMTUxM2UwNjUiLCJlbWFpbCI6ImpkaWV0ekBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwicGluX3BvbGljeSI6eyJyZWdpb25zIjpbeyJkZXNpcmVkUmVwbGljYXRpb25Db3VudCI6MSwiaWQiOiJGUkExIn0seyJkZXNpcmVkUmVwbGljYXRpb25Db3VudCI6MSwiaWQiOiJOWUMxIn1dLCJ2ZXJzaW9uIjoxfSwibWZhX2VuYWJsZWQiOmZhbHNlLCJzdGF0dXMiOiJBQ1RJVkUifSwiYXV0aGVudGljYXRpb25UeXBlIjoic2NvcGVkS2V5Iiwic2NvcGVkS2V5S2V5IjoiOTNmNWNjYTMwOWZlMjczZmNiOGIiLCJzY29wZWRLZXlTZWNyZXQiOiIyZDViYzRmNDQzN2JkYjZiYWQ5MmY3ZDBlNzllMDUxMmUxNWZjYzA5ZmQ0ZTQzNTk3OWEzM2I4NWRjMDJjODU5IiwiZXhwIjoxNzgyOTgzNjAwfQ.F70pd6jxBmYhslA2N8YH8TV32uz43jRJyykNrI53Vrw';
                        const PINATA_GATEWAY = 'https://gateway.pinata.cloud/ipfs/';
                        let genesisTimeMs = Date.now(); // overwritten after block fetch
                        let currentSeed = '0';

                        function log(...args) { console.log('[MetaLife]', ...args); }

                        // ---- Genesis / Age ----
                        (async function initGenesis() {
                            try {
                                const blk = await ethProvider.getBlock('latest');
                                genesisTimeMs = blk.timestamp * 1000;
                            } catch (e) { console.warn('Failed to fetch block timestamp, using now'); }
                        })();
                        setInterval(() => {
                            const delta = Date.now() - genesisTimeMs;
                            const s = Math.floor(delta / 1000);
                            const h = Math.floor(s / 3600);
                            const m = Math.floor((s % 3600) / 60);
                            const sec = s % 60;
                            const el = document.getElementById('ageDisplay');
                            if (el) el.textContent = `${h}h ${m}m ${sec}s`;
                        }, 1000);

                        // ---- Ethereum helper ----
                        async function showBlockNumber() {
                            try {
                                const bn = await ethProvider.getBlockNumber();
                                alert('Current main-net block: ' + bn);
                            } catch (e) {
                                console.error('[MetaLife] Block fetch failed', e);
                                alert('Failed to fetch block number');
                            }
                        }

                        // ---- Web3 wallet integration ----
                        async function connectWallet(autoRequest = false) {
                            if (!window.ethereum) {
                                if (!autoRequest) alert('No crypto wallet detected');
                                return;
                            }
                            try {
                                const provider = new ethers.providers.Web3Provider(window.ethereum);
                                let accounts = [];
                                if (autoRequest) {
                                    accounts = await provider.send('eth_accounts', []);
                                } else {
                                    accounts = await provider.send('eth_requestAccounts', []);
                                }
                                if (!accounts.length) {
                                    if (!autoRequest) alert('No wallet accounts found');
                                    return;
                                }
                                const addr = accounts[0];
                                const seed = ethers.utils.keccak256(addr).slice(2, 18);
                                const seedInput = document.getElementById('seed');
                                if (seedInput) seedInput.value = seed;
                                const addrInput = document.getElementById('address');
                                if (addrInput) addrInput.value = addr;
                                applySeed(seed);
                                log(autoRequest ? 'Auto-seeded from wallet' : 'Seeded from wallet', addr);
                            } catch (err) {
                                console.error('[MetaLife] Wallet connect failed', err);
                                if (!autoRequest) alert('Wallet connect failed – check console.');
                            }
                        }

                        // ---------------- Verifiable Duel -----------------
                        function spawnCAFromSeed(seed) {
                            applySeed(seed);
                            if (typeof buyCA === 'function') {
                                const before = allActiveCAs.length;
                                buyCA();
                                return allActiveCAs[before];
                            }
                            return null;
                        }

                        async function runDuelLocal(seedA, seedB, steps) {
                            if (window.reInitialize) window.reInitialize();
                            allActiveCAs.length = 0; // clear existing
                            numberofComputationalStepsCompleted = 0;
                            MAXSTEPS = steps;
                            spawnCAFromSeed(seedA);
                            spawnCAFromSeed(seedB);
                            for (let i = 0; i < steps; i++) {
                                if (typeof runOneStep === 'function') runOneStep();
                            }
                            return grabWorldState();
                        }

                        async function publishDuel() {
                            if (!ipfs) { alert('IPFS not ready'); return; }
                            const seedA = document.getElementById('seedA').value || 'A' + Date.now();
                            const seedB = document.getElementById('seedB').value || 'B' + Date.now();
                            const steps = parseInt(document.getElementById('duelSteps').value) || 1000;
                            log('Running duel', seedA, seedB, steps);
                            const state = await runDuelLocal(seedA, seedB, steps);
                            const { cid: stateCID } = await ipfs.add(state);
                            const stateHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes(state));
                            const manifest = JSON.stringify({ version: 'MetaLife-0.33', steps, seedA, seedB, stateCID: stateCID.toString(), stateHash });
                            const { cid: manifestCID } = await ipfs.add(manifest);
                            document.getElementById('manifestCid').value = manifestCID.toString();
                            alert('Manifest stored: ' + manifestCID);
                            // ---- update duel index ----
                            const indexInput = document.getElementById('indexCid');
                            if (indexInput && indexInput.value) {
                                try {
                                    let list = [];
                                    let txt = '';
                                    for await (const c of ipfs.cat(indexInput.value.trim())) txt += new TextDecoder().decode(c);
                                    list = JSON.parse(txt);
                                    if (!Array.isArray(list)) list = [];
                                } catch (e) { list = []; }
                                list.push(manifestCID.toString());
                                const { cid: newIndexCid } = await ipfs.add(JSON.stringify(list));
                                indexInput.value = newIndexCid.toString();
                                log('Index updated', newIndexCid.toString());
                            }
                        }

                        async function refreshDuelList() {
                            const indexCid = document.getElementById('indexCid').value.trim();
                            if (!indexCid) { alert('Set Index CID first'); return; }
                            let txt = '';
                            try {
                                for await (const c of ipfs.cat(indexCid)) txt += new TextDecoder().decode(c);
                                const list = JSON.parse(txt);
                                const sel = document.getElementById('duelList');
                                sel.innerHTML = '';
                                list.forEach(cid => {
                                    const opt = document.createElement('option');
                                    opt.value = cid; opt.textContent = cid.slice(0, 10) + '…' + cid.slice(-4);
                                    sel.appendChild(opt);
                                });
                            } catch (e) {
                                console.error('Failed to load index', e);
                                alert('Failed to load index');
                            }
                        }

                        async function verifyDuel() {
                            if (!ipfs) { alert('IPFS not ready'); return; }
                            const cid = document.getElementById('manifestCid').value.trim();
                            if (!cid) { alert('No manifest CID'); return; }
                            log('Verifying manifest', cid);
                            let data = '';
                            for await (const chunk of ipfs.cat(cid)) { data += new TextDecoder().decode(chunk); }
                            const manifest = JSON.parse(data);
                            const state = await runDuelLocal(manifest.seedA, manifest.seedB, manifest.steps);
                            const localHash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes(state));
                            if (localHash === manifest.stateHash) { alert('Verification success!'); }
                            else { alert('Verification FAILED!'); console.error('expected', manifest.stateHash, 'got', localHash); }
                        }

                        // silent attempt on load
                        if (window.ethereum) {
                            connectWallet(true);
                        }

                        function applySeed(seed = document.getElementById('seed')?.value || Date.now().toString()) {
                            currentSeed = seed.toString();
                            Math.seedrandom(currentSeed, { global: true });
                            const seedInput = document.getElementById('seed');
                            if (seedInput) seedInput.value = currentSeed;
                            log('Seed set', currentSeed);
                            if (window.reInitialize) window.reInitialize();
                        }

                        // Initialize IPFS client with Pinata
                        (async () => {
                            try {
                                // Create wrapper for Pinata API
                                ipfs = {
                                    add: async (dataStr) => {
                                        const res = await fetch('https://api.pinata.cloud/pinning/pinJSONToIPFS', {
                                            method: 'POST',
                                            headers: {
                                                'Content-Type': 'application/json',
                                                'Authorization': `Bearer ${PINATA_JWT}`
                                            },
                                            body: JSON.stringify({ pinataContent: JSON.parse(dataStr) })
                                        });
                                        if (!res.ok) throw new Error(await res.text());
                                        const { IpfsHash } = await res.json();
                                        return { cid: { toString: () => IpfsHash } };
                                    },
                                    cat: async function* (cid) {
                                        const r = await fetch(PINATA_GATEWAY + cid);
                                        const reader = r.body.getReader();
                                        while (true) {
                                            const { done, value } = await reader.read();
                                            if (done) break;
                                            yield value;
                                        }
                                    }
                                };
                                log('Pinata client ready');
                            } catch (err) {
                                console.error('[MetaLife] Failed to init Pinata IPFS:', err);
                            }
                        })();

                        function mutate(parent, mutRate = parent.mutation || 10) {
                            if (!parent || !parent.clone) return null;
                            const child = parent.clone("ca_" + Math.floor(Math.random() * 1e9));

                            // Initialize or inherit direction vector
                            if (!parent.direction) {
                                parent.direction = new BABYLON.Vector3(
                                    Math.random() * 2 - 1,
                                    Math.random() * 2 - 1,
                                    Math.random() * 2 - 1
                                ).normalize();
                            }

                            // Curve parameters - new genetic properties
                            if (!parent.curveFactor) parent.curveFactor = 0.2 + Math.random() * 0.6; // How much it curves
                            if (!parent.curveAxis) {
                                // Random perpendicular axis to curve around
                                const perpVec = new BABYLON.Vector3(
                                    Math.random() * 2 - 1,
                                    Math.random() * 2 - 1,
                                    Math.random() * 2 - 1
                                ).normalize();
                                parent.curveAxis = BABYLON.Vector3.Cross(parent.direction, perpVec).normalize();
                            }

                            // Inherit and mutate direction
                            child.direction = parent.direction.clone();
                            // Apply gentle curve to direction
                            const rotationQuat = BABYLON.Quaternion.RotationAxis(
                                parent.curveAxis,
                                parent.curveFactor * 0.1 * Math.PI
                            );
                            child.direction = child.direction.rotateByQuaternionToRef(rotationQuat, new BABYLON.Vector3());

                            // Add small random jitter to direction
                            const jitterVec = new BABYLON.Vector3(
                                (Math.random() * 2 - 1) * 0.2,
                                (Math.random() * 2 - 1) * 0.2,
                                (Math.random() * 2 - 1) * 0.2
                            );
                            child.direction.addInPlace(jitterVec).normalize();

                            // Position child along the curved direction
                            child.position = parent.position.add(child.direction.scale(3 + Math.random() * 2));

                            // Mutate curve properties
                            const jitter = (v) => Math.max(1, v + (Math.random() * 2 - 1) * mutRate);
                            child.curveFactor = Math.max(0.05, Math.min(0.9, parent.curveFactor + (Math.random() * 0.4 - 0.2)));

                            // Slightly rotate curve axis
                            const axisRotation = BABYLON.Quaternion.RotationAxis(
                                child.direction,
                                (Math.random() * 0.4 - 0.2) * Math.PI
                            );
                            child.curveAxis = parent.curveAxis.clone();
                            child.curveAxis = child.curveAxis.rotateByQuaternionToRef(axisRotation, new BABYLON.Vector3()).normalize();

                            // Original gene mutations
                            child.xFreq = jitter(parent.xFreq || 10);
                            child.yFreq = jitter(parent.yFreq || 10);
                            child.zFreq = jitter(parent.zFreq || 10);
                            child.splitFreq = Math.max(5, Math.round(jitter(parent.splitFreq || 10)));
                            child.mutation = parent.mutation; // keep same rate for now
                            child.energy = (parent.energy || 10) / 2;
                            parent.energy = child.energy; // share energy
                            // mutate color slightly
                            try {
                                const col = BABYLON.Color3.FromHexString(parent.color || "#ffffff");
                                const h = (col.r + col.g + col.b) / 3;
                                const newCol = new BABYLON.Color3(
                                    Math.min(1, Math.abs(col.r + (Math.random() - 0.5) * 0.2)),
                                    Math.min(1, Math.abs(col.g + (Math.random() - 0.5) * 0.2)),
                                    Math.min(1, Math.abs(col.b + (Math.random() - 0.5) * 0.2)));
                                child.material = parent.material.clone("mat_" + Date.now());
                                child.material.emissiveColor = newCol;
                                child.color = newCol.toHexString();
                            } catch (e) { }
                            child.ruleMask = parent.ruleMask ^ (1 << Math.floor(Math.random() * 32));
                            child.liveVoxels = new Set(parent.liveVoxels); // shallow copy
                            allActiveCAs.push(child);
                            return child;
                        }

                        function encodeCoord(x, y, z) { return `${x},${y},${z}`; }
                        function decodeCoord(s) { const [x, y, z] = s.split(',').map(Number); return { x, y, z }; }

                        function stepVoxels(ca) {
                            const live = ca.liveVoxels;
                            const counts = new Map();

                            // Initialize direction if not present
                            if (!ca.direction) {
                                ca.direction = new BABYLON.Vector3(
                                    Math.random() * 2 - 1,
                                    Math.random() * 2 - 1,
                                    Math.random() * 2 - 1
                                ).normalize();
                                ca.curveFactor = 0.2 + Math.random() * 0.6;

                                // Create perpendicular axis for curving
                                const perpVec = new BABYLON.Vector3(
                                    Math.random() * 2 - 1,
                                    Math.random() * 2 - 1,
                                    Math.random() * 2 - 1
                                ).normalize();
                                ca.curveAxis = BABYLON.Vector3.Cross(ca.direction, perpVec).normalize();
                            }

                            // Slightly evolve direction over time for continuous curving
                            const rotationQuat = BABYLON.Quaternion.RotationAxis(
                                ca.curveAxis,
                                ca.curveFactor * 0.02 * Math.PI
                            );
                            ca.direction = ca.direction.rotateByQuaternionToRef(rotationQuat, new BABYLON.Vector3()).normalize();

                            // Count neighbors with directional bias
                            live.forEach(key => {
                                const { x, y, z } = decodeCoord(key);

                                // Calculate center of mass for this CA
                                if (!ca.centerOfMass) {
                                    ca.centerOfMass = { x: 0, y: 0, z: 0, count: 0 };
                                    live.forEach(voxKey => {
                                        const pos = decodeCoord(voxKey);
                                        ca.centerOfMass.x += pos.x;
                                        ca.centerOfMass.y += pos.y;
                                        ca.centerOfMass.z += pos.z;
                                        ca.centerOfMass.count++;
                                    });
                                    if (ca.centerOfMass.count > 0) {
                                        ca.centerOfMass.x /= ca.centerOfMass.count;
                                        ca.centerOfMass.y /= ca.centerOfMass.count;
                                        ca.centerOfMass.z /= ca.centerOfMass.count;
                                    }
                                }

                                for (let dx = -1; dx <= 1; dx++)
                                    for (let dy = -1; dy <= 1; dy++)
                                        for (let dz = -1; dz <= 1; dz++) {
                                            if (dx || dy || dz) {
                                                const nx = x + dx;
                                                const ny = y + dy;
                                                const nz = z + dz;
                                                const k = encodeCoord(nx, ny, nz);

                                                // Calculate directional bias
                                                let weight = 1.0;

                                                // Vector from center of mass to this neighbor
                                                const growthVec = new BABYLON.Vector3(
                                                    nx - ca.centerOfMass.x,
                                                    ny - ca.centerOfMass.y,
                                                    nz - ca.centerOfMass.z
                                                ).normalize();

                                                // Favor growth in the direction of the curve
                                                const alignment = BABYLON.Vector3.Dot(growthVec, ca.direction);

                                                // Boost weight for cells growing in the preferred direction
                                                if (alignment > 0) {
                                                    weight = 1.0 + alignment * 0.5;
                                                }

                                                counts.set(k, (counts.get(k) || 0) + weight);
                                            }
                                        }
                            });

                            const next = new Set();
                            counts.forEach((n, k) => {
                                const alive = live.has(k);
                                const maskPart = alive ? (ca.ruleMask >>> 16) : ca.ruleMask;

                                // Round to nearest integer for rule application
                                const nInt = Math.round(n);

                                if (((maskPart >> nInt) & 1) === 1) next.add(k);
                            });

                            // Reset center of mass for next step
                            ca.centerOfMass = null;
                            ca.liveVoxels = next;
                        }

                        function serializeCA(ca) {
                            if (!ca) return {};
                            return {
                                x: ca.position?.x || 0,
                                y: ca.position?.y || 0,
                                z: ca.position?.z || 0,
                                energy: ca.energy,
                                seed: ca.seed,
                                color: ca.color,
                                xFreq: ca.xFreq,
                                yFreq: ca.yFreq,
                                zFreq: ca.zFreq,
                                splitFreq: ca.splitFreq,
                                mutation: ca.mutation,
                                ruleMask: ca.ruleMask || 0,
                                voxels: Array.from(ca.liveVoxels || []),
                                // New directional properties
                                direction: ca.direction ? {
                                    x: ca.direction.x,
                                    y: ca.direction.y,
                                    z: ca.direction.z
                                } : null,
                                curveFactor: ca.curveFactor || 0.2,
                                curveAxis: ca.curveAxis ? {
                                    x: ca.curveAxis.x,
                                    y: ca.curveAxis.y,
                                    z: ca.curveAxis.z
                                } : null
                            };
                        }

                        function grabWorldState() {
                            try {
                                const state = {
                                    seed: currentSeed,
                                    step: window.numberofComputationalStepsCompleted || 0,
                                    caList: (window.allActiveCAs || []).map(ca => serializeCA(ca))
                                };
                                const ordered = {};
                                Object.keys(state).sort().forEach(k => { ordered[k] = state[k]; });
                                return JSON.stringify(ordered);
                            } catch (err) {
                                console.error('[MetaLife] Failed to grab state:', err);
                                return '{}';
                            }
                        }

                        async function loadSnapshot() {
                            const cidInput = document.getElementById('cid');
                            if (!cidInput || !cidInput.value) return;
                            const cidStr = cidInput.value.trim();
                            if (!ipfs) { alert('IPFS not ready'); return; }
                            try {
                                log('Fetching snapshot', cidStr);
                                let dataStr = '';
                                for await (const chunk of ipfs.cat(cidStr)) {
                                    dataStr += new TextDecoder().decode(chunk);
                                }
                                const state = JSON.parse(dataStr);
                                
                                // Clear existing scene
                                if (window.scene) {
                                    // Remove all meshes
                                    const meshes = [...window.scene.meshes];
                                    for (const mesh of meshes) {
                                        if (mesh.name !== 'ground' && mesh.name !== 'camera') {
                                            mesh.dispose();
                                        }
                                    }
                                }
                                
                                // Reset state
                                window.allActiveCAs = [];
                                
                                // Apply new state
                                applySeed(state.seed);
                                window.numberofComputationalStepsCompleted = state.step || 0;
                                
                                // Deserialize CA objects
                                if (Array.isArray(state.caList)) {
                                    log(`Loading ${state.caList.length} life forms...`);
                                    window.allActiveCAs = state.caList.map(deserializeCA);
                                }
                                
                                // Reinitialize scene
                                if (window.reInitialize) window.reInitialize();
                                
                                log('Snapshot loaded successfully');
                            } catch (err) {
                                console.error('[MetaLife] Load failed:', err);
                                alert('Load failed – check console.');
                            }
                        }

                        async function snapshotState() {
                            if (!ipfs) { log('IPFS not ready for snapshot'); return; }

                            try {
                                // Get current state
                                const state = grabWorldState();
                                const stateStr = JSON.stringify(state);

                                // Save to IPFS
                                const { cid } = await ipfs.add(stateStr);
                                const cidStr = cid.toString();

                                // Create snapshot entry
                                const snapshotNameEl = document.getElementById('snapshotName');
                                const snapshotName = snapshotNameEl ? snapshotNameEl.value : `Snapshot ${Date.now()}`;
                                const snapshot = {
                                    cid: cidStr,
                                    name: snapshotName,
                                    timestamp: Date.now(),
                                    description: `MetaLife state snapshot: ${window.allActiveCAs ? window.allActiveCAs.length : 0} life forms`
                                };

                                // Add to registry
                                if (!snapshotRegistry.snapshots) snapshotRegistry.snapshots = [];
                                snapshotRegistry.snapshots.push(snapshot);

                                // Save registry
                                await saveSnapshotRegistry();
                                
                                // Update the UI
                                updateSnapshotListUI();

                                log(`Snapshot saved: ${snapshotName} (CID: ${cidStr})`);
                                log(`Registry now has ${snapshotRegistry.snapshots.length} snapshots`);
                                return cidStr;
                            } catch (err) {
                                console.error('[MetaLife] Snapshot failed:', err);
                                return null;
                            }
                        }

                        // Function to deserialize a CA from JSON to a live object
                        function deserializeCA(data) {
                            if (!data) return null;
                            
                            // Create a new CA object
                            const ca = {
                                position: new BABYLON.Vector3(data.x || 0, data.y || 0, data.z || 0),
                                energy: data.energy || 100,
                                seed: data.seed,
                                color: data.color || '#ffffff',
                                xFreq: data.xFreq || 10,
                                yFreq: data.yFreq || 10,
                                zFreq: data.zFreq || 10,
                                splitFreq: data.splitFreq || 10,
                                mutation: data.mutation || 10,
                                ruleMask: data.ruleMask || 0,
                                liveVoxels: new Set(data.voxels || []),
                                // Restore directional properties
                                direction: data.direction ? new BABYLON.Vector3(
                                    data.direction.x || 0,
                                    data.direction.y || 0,
                                    data.direction.z || 0
                                ).normalize() : null,
                                curveFactor: data.curveFactor || 0.2,
                                curveAxis: data.curveAxis ? new BABYLON.Vector3(
                                    data.curveAxis.x || 0,
                                    data.curveAxis.y || 0,
                                    data.curveAxis.z || 0
                                ).normalize() : null
                            };
                            
                            // Initialize direction and curve axis if not present
                            if (!ca.direction) {
                                ca.direction = new BABYLON.Vector3(
                                    Math.random() * 2 - 1,
                                    Math.random() * 2 - 1,
                                    Math.random() * 2 - 1
                                ).normalize();
                            }
                            
                            if (!ca.curveAxis) {
                                const perpVec = new BABYLON.Vector3(
                                    Math.random() * 2 - 1,
                                    Math.random() * 2 - 1,
                                    Math.random() * 2 - 1
                                ).normalize();
                                ca.curveAxis = BABYLON.Vector3.Cross(ca.direction, perpVec).normalize();
                            }
                            
                            // Create mesh for visualization
                            if (window.scene) {
                                ca.mesh = BABYLON.MeshBuilder.CreateBox('ca_' + Math.floor(Math.random() * 1e9), {
                                    size: 1
                                }, window.scene);
                                ca.mesh.position = ca.position.clone();
                                ca.mesh.material = new BABYLON.StandardMaterial('mat_' + ca.mesh.name, window.scene);
                                ca.mesh.material.diffuseColor = BABYLON.Color3.FromHexString(ca.color);
                                ca.mesh.material.alpha = 0.8;
                                ca.mesh.scaling = new BABYLON.Vector3(0.5, 0.5, 0.5);
                            }
                            
                            return ca;
                        }
                        
                        // Initialize IPFS and registry when the page loads
                        window.addEventListener('load', function () {
                            // Display registry status immediately if available
                            updateRegistryStatus();
                            
                            // Check for IPFS periodically
                            const checkIpfs = setInterval(function () {
                                if (window.ipfs) {
                                    clearInterval(checkIpfs);
                                    log('IPFS ready, loading snapshot registry...');
                                    setTimeout(() => {
                                        loadSnapshotRegistry();
                                        // Force update UI after loading
                                        updateRegistryStatus();
                                        showRegistryContents();
                                    }, 1000); // Add a delay to ensure IPFS is fully ready
                                }
                            }, 1000);
                        });

                        // Initialize seed
                        applySeed();
                    </script>
                    <!-- ==== FVM Render-Reward integration ===================================== -->
                    <script>
                        const TOKEN_ADDR = "0xYourDeployedAddress"; // TODO: replace after deployment
                        const FVM_RPC = "https://wallaby.node.glif.io/rpc/v1";
                        const tokenAbi = [
                            "function mintWithProof(address to, bytes manifestCID, uint256 steps, bytes32 stateHash, bytes ownerSig)"
                        ];

                        const providerFVM = new ethers.providers.JsonRpcProvider(FVM_RPC);
                        let fvmSigner = null;
                        let tokenRead = null;
                        let tokenWrite = null;

                        async function connectFVM() {
                            if (!window.ethereum) { alert('Wallet not found'); return; }
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: '0xC45',
                                    chainName: 'Filecoin Hyperspace',
                                    nativeCurrency: { name: 'tFIL', symbol: 'tFIL', decimals: 18 },
                                    rpcUrls: [FVM_RPC],
                                    blockExplorerUrls: ['https://hyperspace.filfox.info/en/']
                                }]
                            });
                            await window.ethereum.request({ method: 'eth_requestAccounts' });
                            fvmSigner = new ethers.providers.Web3Provider(window.ethereum).getSigner();
                            tokenRead = new ethers.Contract(TOKEN_ADDR, tokenAbi, providerFVM);
                            tokenWrite = tokenRead.connect(fvmSigner);
                            console.log('[FVM] Connected', await fvmSigner.getAddress());
                        }

                        async function signProof(manifestBytes, steps, stateHash) {
                            if (!fvmSigner) throw new Error('connectFVM first');
                            const msgHash = ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['bytes', 'uint256', 'bytes32'], [manifestBytes, steps, stateHash]));
                            return await fvmSigner.signMessage(ethers.utils.arrayify(msgHash));
                        }

                        async function mintReward(manifestBytes, steps, stateHash, ownerSig) {
                            if (!tokenWrite) throw new Error('connectFVM first');
                            const tx = await tokenWrite.mintWithProof(await fvmSigner.getAddress(), manifestBytes, steps, stateHash, ownerSig);
                            await tx.wait();
                            alert('Reward minted on FVM');
                        }
                        window.connectFVM = connectFVM;
                        window.signProof = signProof;
                        window.mintReward = mintReward;
                    </script>
                    <!-- ====================================================================== -->
                    </script>
</body>

</html>